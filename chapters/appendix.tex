\chapter{Appendix}
\label{ch:appendix}

\section{System Specifications}
Experiments and code executions have been made on a systems with the following specifications:

\subsection{Local Linux System}
\label{app:system:mymachine}
\begin{itemize}
    \item \textbf{CPU:} Intel(R) Core(TM) i5-8250U CPU @ 1.60GHz
    \item \textbf{RAM:} 15 Gi (15.4667 GB)
    \item \textbf{Operating System:} Ubuntu 20.04.6 LTS
    \item \textbf{Kernel:} 5.15.0-119-generic
    \item \textbf{GPU:} Intel Corporation UHD Graphics 620 (rev 07)
\end{itemize}

\subsection{Server Linux System}
\label{app:system:server}
\begin{itemize}
    \item \textbf{CPU:} Intel Xeon Processor (Cascadelake)
    \item \textbf{RAM:} 3.8 Gi
    \item \textbf{Operating System:} Ubuntu 24.04.1 LTS
    \item \textbf{Kernel:} 6.8.0-36-generic
    \item \textbf{GPU:} Cirrus Logic GD 5446
\end{itemize}

\subsection{Raspberry Pi Linux System}
\label{app:system:pi}
\begin{itemize}
    \item \textbf{CPU:} Raspberry Pi 4 Model B Rev 1.4
    \item \textbf{RAM:} 7.7 Gi
    \item \textbf{Operating System:} Ubuntu 22.04.3 LTS
    \item \textbf{Kernel:} 5.15.0-1034-raspi
\end{itemize}

\section{Sourcecode and Output}

\subsection{Calculation of Mandelbrot Set: Go}
\label{app:code:mandelbrot1}
Below is the Go source code for generating a colored PNG file of the Mandelbrot set:

\begin{lstlisting}[language=go, frame=tb, caption={Mandelbrot Set Calculation}]
    package main

    import (
        "os"
        "fmt"
        "image"
        "image/color"
        "image/png"
        "math"
        "math/cmplx"
        "time"
    )
    
    func main() {
        startTime := time.Now()
    
        // Set Parameters
        width := 1500
        height := 1500
        maxIterations := 3000
        realMin := -2.0
        realMax := 1.0
        imagMin := -1.5
        imagMax := 1.5
    
        img := image.NewRGBA(image.Rect(0, 0, width, height))
        fmt.Println("Generating PNG of Mandelbrot set... ")
    
        // Calculate Mandelbrot for each Pixel
        for py := 0; py < height; py++ {
            y := imagMax - float64(py)/float64(height)*(imagMax-imagMin)
            for px := 0; px < width; px++ {
                x := float64(px)/float64(width)*(realMax-realMin) + realMin
                z := complex(x, y)
                c := z
                iteration := mandelbrot(z, c, maxIterations)
    
                // Paint Pixel depending on Iteration count
                if iteration >= maxIterations {
                    img.Set(px, py, color.Black)
                } else {
                    img.Set(px, py, colorize(iteration))
                }
            }
        }
    
        // Save PNG
        f, _ := os.Create("mandelbrot_theory.png")
        png.Encode(f, img)
        f.Close()
    
        // Calculate and Print Computation Time
        elapsedTime := time.Since(startTime)
        fmt.Printf("Mandelbrot PNG generation completed in %v\n", elapsedTime)
    }
    
    // Mandelbrot Algorithm
    func mandelbrot(z, c complex128, maxIterations int) (int, float64) {
        var v complex128
        for i := 0; i < maxIterations; i++ {
            if cmplx.Abs(z) > 2 {
                log_zn := math.Log(real(z)*real(z) + imag(z)*imag(z)) / 2
                nu := math.Log(log_zn / math.Log(2)) / math.Log(2)
                return i, float64(i) + 1 - nu
            }
            z = z*z + c
            if z == v {
                return maxIterations, 0
            }
            v = z
        }
        return maxIterations, 0
    }
    
    // Set Color for Pixel
    func colorize(t float64) color.Color {
        t = math.Mod(t*0.1, 1.0) // Adjust color cycle frequency
        hue := 6 * t
        saturation := 1.0
        value := 1.0
        if t >= 1.0 {
            hue = 0
            saturation = 0
            value = 0
        }
    
        hi := math.Floor(hue)
        f := hue - hi
        p := value * (1 - saturation)
        q := value * (1 - saturation*f)
        t = value * (1 - saturation*(1-f))
    
        var r, g, b float64
        switch int(hi) % 6 {
            case 0:
                r, g, b = value, t, p
            case 1:
                r, g, b = q, value, p
            case 2:
                r, g, b = p, value, t
            case 3:
                r, g, b = p, q, value
            case 4:
                r, g, b = t, p, value
            case 5:
                r, g, b = value, p, q
        }
    
        return color.RGBA{
            uint8(r * 255),
            uint8(g * 255),
            uint8(b * 255),
            255,
        }
    }    
\end{lstlisting}

This code has been executed in three isolated runs as follows:
\begin{lstlisting}
    go run mandelbrot_native.go
\end{lstlisting}

The output of this code on the system specified in \ref{app:system:mymachine} was:
\begin{lstlisting}
    Generating PNG of Mandelbrot set... 
    Mandelbrot PNG generation completed in 33.592224199s
\end{lstlisting}
\begin{lstlisting}
    Generating PNG of Mandelbrot set... 
    Mandelbrot PNG generation completed in 34.73396341s
\end{lstlisting}
\begin{lstlisting}
    Generating PNG of Mandelbrot set... 
    Mandelbrot PNG generation completed in 36.602893897s
\end{lstlisting}

\subsection{Calculation of Mandelbrot Set: Go (WASM build)}
\label{app:code:mandelbrot2}
Below is the Go source code for generating a colored PNG file of the Mandelbrot set with all additions to be compiled to a .wasm file and utilized in the browser:

\begin{lstlisting}[language=go, frame=tb, caption={Mandelbrot Set Calculation (WASM build)}]
    package main

    import (
        "bytes"
        "strconv"
        "fmt"
        "image"
        "image/color"
        "image/png"
        "math"
        "math/cmplx"
        "syscall/js"
        "time"
    )
    
    func main() {
        fmt.Println("Hello Webassembly")
        c := make(chan bool)
        js.Global().Set("wasmMain", js.FuncOf(wasmMain))
        <-c
    }
    
    func wasmMain(this js.Value, args []js.Value) any {
        startTime := time.Now()
    
        // Get Input Arguments
        width, _ := strconv.Atoi(args[0].String())
        height, _ := strconv.Atoi(args[1].String())
        maxIterations, _ := strconv.Atoi(args[2].String())
        realMin, _ := strconv.ParseFloat(args[3].String(), 64)
        realMax, _ := strconv.ParseFloat(args[4].String(), 64)
        imagMin, _ := strconv.ParseFloat(args[5].String(), 64)
        imagMax, _ := strconv.ParseFloat(args[6].String(), 64)
    
        img := image.NewRGBA(image.Rect(0, 0, width, height))
        fmt.Println("Generating PNG of Mandelbrot set... ")
    
        // Calculate Mandelbrot for each Pixel
        for py := 0; py < height; py++ {
            y := imagMax - float64(py)/float64(height)*(imagMax-imagMin)
            for px := 0; px < width; px++ {
                x := float64(px)/float64(width)*(realMax-realMin) + realMin
                z := complex(x, y)
                c := z
    
                iteration := mandelbrot(z, c, maxIterations)
    
                // Paint Pixel depending on Iteration count
                if iteration >= maxIterations {
                    img.Set(px, py, color.Black)
                } else {
                    img.Set(px, py, colorize(iteration))
                }
            }
        }
    
        // Generate PNG BLOB
        var buf bytes.Buffer
        png.Encode(&buf, img)
    
        elapsedTime := time.Since(startTime)
        fmt.Printf("Mandelbrot PNG generation completed in %v\n", elapsedTime)
    
        // Convert []byte to JS Uint8Array
        uint8Array := js.Global().Get("Uint8Array").New(buf.Len())
        js.CopyBytesToJS(uint8Array, buf.Bytes())
    
        return uint8Array
    }
    
    // Mandelbrot Algorithm
    func mandelbrot(z, c complex128, maxIterations int) (int, float64) {
        var v complex128
        for i := 0; i < maxIterations; i++ {
            if cmplx.Abs(z) > 2 {
                log_zn := math.Log(real(z)*real(z) + imag(z)*imag(z)) / 2
                nu := math.Log(log_zn / math.Log(2)) / math.Log(2)
                return i, float64(i) + 1 - nu
            }
            z = z*z + c
            if z == v {
                return maxIterations, 0
        }
        v = z
        }
        return maxIterations, 0
    }
    
    // Set Color for Pixel
    func colorize(t float64) color.Color {
        t = math.Mod(t*0.1, 1.0) // Adjust color cycle frequency
        hue := 6 * t
        saturation := 1.0
        value := 1.0
        if t >= 1.0 {
            hue = 0
            saturation = 0
            value = 0
        }
    
        hi := math.Floor(hue)
        f := hue - hi
        p := value * (1 - saturation)
        q := value * (1 - saturation*f)
        t = value * (1 - saturation*(1-f))
    
        var r, g, b float64
        switch int(hi) % 6 {
            case 0:
                r, g, b = value, t, p
            case 1:
                r, g, b = q, value, p
            case 2:
                r, g, b = p, value, t
            case 3:
                r, g, b = p, q, value
            case 4:
                r, g, b = t, p, value
            case 5:
                r, g, b = value, p, q
        }
    
        return color.RGBA{
            uint8(r * 255),
            uint8(g * 255),
            uint8(b * 255),
            255,
        }
    }    
\end{lstlisting}

\begin{lstlisting}[language=html, frame=tb, caption={Execute \emph{mandelbrot.wasm} in Browser (HTML)}]
    <!DOCTYPE html>
    <html lang="en">
    <head>
        <meta charset="UTF-8">
        <title>Mandelbrot Set with WebAssembly</title>
        <script src="wasm_exec.js"></script>
    </head>
    <body>
        <h1>Mandelbrot Set Calculator</h1>
        <button id="calculate">Calculate Mandelbrot Set</button>
        <br><br>
        <img id="mandelbrotImage" alt="Mandelbrot Set">
        <script>                 
            // Set Up WebAssembly Environment
            const go = new Go();
            let wasmInstance;
    
            WebAssembly.instantiateStreaming(fetch("mandelbrot.wasm"), go.importObject).then((result) => {
                wasmInstance = result.instance;
                go.run(wasmInstance);
            });
    
            document.getElementById('calculate').addEventListener('click', () => {
                const pngData = wasmMain('1500', '1500', '3000', '-2.0', '1.0', '-1.5', '1.5');
                
                // Create a Blob from the PNG data
                const blob = new Blob([pngData], {type: 'image/png'});
                const url = URL.createObjectURL(blob);
                              
                // Display the image
                const img = document.getElementById('mandelbrotImage');
                img.src = url;
                img.onload = () => URL.revokeObjectURL(url);  // Clean up the object URL
            });
        </script>
    </body>
    </html>
\end{lstlisting}

This code has been executed in three isolated runs as follows:
\begin{lstlisting}
    go run mandelbrot_native.go
\end{lstlisting}

The output of this code on the system specified in \ref{app:system:mymachine} was:
\begin{lstlisting}
    Generating PNG of Mandelbrot set... 
    Mandelbrot PNG generation completed in 1m11.048999936s
\end{lstlisting}
\begin{lstlisting}
    Generating PNG of Mandelbrot set... 
    Mandelbrot PNG generation completed in 1m11.327000064s
\end{lstlisting}
\begin{lstlisting}
    Generating PNG of Mandelbrot set... 
    Mandelbrot PNG generation completed in 1m11.123000064s
\end{lstlisting}

\subsection{Calculation of Mandelbrot Set: Go (native benchmark)}
\label{app:code:mandelbrot3}
Below is the Go source code for generating 101 unique colored \ac{PNG} files of the Mandelbrot set:

\begin{lstlisting}[language=go, frame=tb, caption={Mandelbrot Set Calculation}]
    package main

    import (
        "os"
        "fmt"
        "image"
        "image/color"
        "image/png"
        "math"
        "math/cmplx"
        "time"
    )

    func main() {
        startTime := time.Now()

        // Set Parameters
        width := 1500
        height := 1500
        maxIterations := 3000
        realMin := -2.0
        realMax := 1.0
        imagMin := -1.5
        imagMax := 1.5
        gridSize := 10
        counter := 0
        realStep := (realMax - realMin) / float64(gridSize)
        imagStep := (imagMax - imagMin) / float64(gridSize) 

        // Generate Thumbnail
        generatePNG(counter, width, height, maxIterations, realMin, realMax, imagMin, imagMax)
        counter++
        // Generating Grid
        for y := 0; y < gridSize; y++ {
            imagLower := imagMax - (float64(y + 1) * imagStep)
            imagUpper := imagMax - (float64(y) * imagStep)
            for x := 0; x < gridSize; x++ {
                realLower := realMin + (float64(x) * realStep)
                realUpper := realMin + (float64(x + 1) * realStep)
                generatePNG(counter, width, height, maxIterations, realLower, realUpper, imagLower, imagUpper)
                counter++
            }   
        }

        // Calculate and Print Computation Time
        elapsedTime := time.Since(startTime)
        fmt.Printf("Mandelbrot PNG generation completed in %v\n", elapsedTime)
    }

    // Generate Mandelbrot PNG
    func generatePNG(counter, width, height, maxIterations int, realMin, realMax, imagMin, imagMax float64) {
        img := image.NewRGBA(image.Rect(0, 0, width, height))
        fmt.Printf("Generating PNG #%v of Mandelbrot set...\n", counter)

        // Calculate Mandelbrot for each Pixel
        for py := 0; py < height; py++ {
            y := imagMax - float64(py)/float64(height)*(imagMax-imagMin)
            for px := 0; px < width; px++ {
                x := float64(px)/float64(width)*(realMax-realMin) + realMin
                z := complex(x, y)
                c := z
                iteration := mandelbrot(z, c, maxIterations)

                // Paint Pixel depending on Iteration count
                if iteration >= maxIterations {
                    img.Set(px, py, color.Black)
                } else {
                    img.Set(px, py, colorize(iteration))
                }
            }
        }

        // Save PNG
        f, _ := os.Create(fmt.Sprintf("mandelbrot_%d.png", counter))
        png.Encode(f, img)
        f.Close()
    }

    // Mandelbrot Algorithm
    func mandelbrot(z, c complex128, maxIterations int) (int, float64) {
        var v complex128
        for i := 0; i < maxIterations; i++ {
            if cmplx.Abs(z) > 2 {
                log_zn := math.Log(real(z)*real(z) + imag(z)*imag(z)) / 2
                nu := math.Log(log_zn / math.Log(2)) / math.Log(2)
                return i, float64(i) + 1 - nu
            }
            z = z*z + c
            if z == v {
                return maxIterations, 0
            }
            v = z
        }
        return maxIterations, 0
    }

    // Set Color for Pixel
    func colorize(t float64) color.Color {
        t = math.Mod(t*0.1, 1.0) // Adjust color cycle frequency
        hue := 6 * t
        saturation := 1.0
        value := 1.0
        if t >= 1.0 {
            hue = 0
            saturation = 0
            value = 0
        }

        hi := math.Floor(hue)
        f := hue - hi
        p := value * (1 - saturation)
        q := value * (1 - saturation*f)
        t = value * (1 - saturation*(1-f))

        var r, g, b float64
        switch int(hi) % 6 {
            case 0:
                r, g, b = value, t, p
            case 1:
                r, g, b = q, value, p
            case 2:
                r, g, b = p, value, t
            case 3:
                r, g, b = p, q, value
            case 4:
                r, g, b = t, p, value
            case 5:
                r, g, b = value, p, q
        }

        return color.RGBA{
            uint8(r * 255),
            uint8(g * 255),
            uint8(b * 255),
            255,
        }
    }    
\end{lstlisting}

This code has been executed in three isolated runs as follows:
\begin{lstlisting}
    go run mandelbrot_benchmark.go
\end{lstlisting}

The output of this code on the system specified in \ref{app:system:server} was:
\begin{lstlisting}
    Generating PNG #0 of Mandelbrot set...
       [...]
    Generating PNG #100 of Mandelbrot set...
    Mandelbrot PNG generation completed in 10m43.723762025s
\end{lstlisting}
\begin{lstlisting}
    Generating PNG #0 of Mandelbrot set...
       [...]
    Generating PNG #100 of Mandelbrot set...
    Mandelbrot PNG generation completed in 10m48.318590362s
\end{lstlisting}
\begin{lstlisting}
    Generating PNG #0 of Mandelbrot set...
       [...]
    Generating PNG #100 of Mandelbrot set...
    Mandelbrot PNG generation completed in 10m44.884158311s
\end{lstlisting}